gen.dist <- pairwise.neifst(gtrunchier[, -2], diploid = TRUE)  # Estimate pairwise FSTs according to Nei (1987)
gen.dist
gen.dist <- as.dist(gen.dist)
gen.dist  # can be used instead of com.dist (but in this dataset we have no matching env + spatial data)
tidy_source(###### necessary packages ######
#install.packages("adespatial")
require(adespatial) # for most of the functions
require(ade4) # for s.value plots...
require(spdep) # for MEM, cell2nb...
###### Create fictitious geographical coordinates ######
xy<-cbind(1:15, expand.grid(1:3, 1:5)) # 15 locations in a 3x5 grid
plot(Var2~Var1, data=xy, pch=20, cex=2)
loc<-as.matrix(xy[,2:3]) # these will be our coordinates
ID<-xy[,1] # ID of the sites
###### construction of object of class nb (spdep) with a regular connectivity pattern ######
nb<-cell2nb(3, 5, "rook") # or "queen" for additional diagonal connections
nb #check nr of links
plot(nb, xy[,2:3], col="red", pch=20, cex=2)
###### how to set the length and thus the number of connections ######
nbnear1<-dnearneigh(loc, 0, 1, row.names=ID) # 0 is the lower, 1 is the upper threshold = truncation distance
nbnear1 # same, 44 links
plot(nbnear1, loc, col="red", pch=20, cex=2)
nbnear2<-dnearneigh(loc, 0, 2, row.names=ID)
nbnear2 # nr of links increased
plot(nbnear2, loc, col="red", pch=20, cex=2) # extra links: diagonal + overlapping
nbnear5<-dnearneigh(loc, 0, 5, row.names=ID) # connects them all (>4.472136)
nbnear5
plot(nbnear5, loc, col="red", pch=20, cex=2)
###### construct MEMs ######
###### 1st step: construct spatial weighting matrices (listw) from spatial neighborhood objects (nb) ######
### function for this: nb2listw()
swm1<-nb2listw(nbnear5) # works with simple row-standardization, gives uniform weights to links
swm1
str(swm1)
swm1$weights # weights are the same
### weights can also be applied based on distance between neighbours
### here weights are defined as a function of distance e.g. 1-dij/max(dij)
dist1<-nbdists(nbnear5, loc) # obtain pairwise distances
str(dist1)
w.dist<-lapply(dist1, function(x) 1-x/max(dist(loc))) # you can define any weight here, this is the most used function
swm2<-nb2listw(nbnear5, glist=w.dist)
swm2
str(swm2)
swm2$weights
swm2$weights[[1]] # easiest to check e.g. weights connecting site 1 to all the others
# note the zero: this is the longest distance in the matrix, should be zero due to the function we gave
print(listw2mat(swm2),digits=3) # check the full matrix with all weights
createlistw() # interface that helps you to find the right weight + graph type;
# useful R coding help on the right
###### 2nd step: construct MEMs from spatial weighting matrices (listw) ######
### function for this: mem()
plot(nbnear1, loc, col="red", pch=20, cex=2) # use this simple case first
swm1<-nb2listw(nbnear1)
mem1<-mem(swm1)
mem1
str(mem1)
attr(mem1, "values") # eigenvalues
barplot(attr(mem1, "values"), main="Eigenvalues", cex.main=0.8)
# positive eigenvalue: MEM has positive autocorrelation
plot(mem1) # not too informative (but good for transects)
plot(mem1, SpORcoords=loc, nb=nbnear1) # without nb, connections are not plotted
plot(mem1$MEM1~loc[,2], pch=20, cex=2)
plot(mem1$MEM2~loc[,1], pch=20, cex=2)
mem2<-mem(swm2) # with longer possible connections
barplot(attr(mem2, "values"), main="Eigenvalues", cex.main=0.8)
plot(mem2, SpORcoords=loc, nb=nbnear2) # still very similar MEMs
# compare 1st MEM from both models
par(mfrow=c(1,2))
s.value(loc, mem1$MEM1, sub="MEM 1", csub=2)
s.value(loc, mem2$MEM1, sub="MEM 1", csub=2)
par(mfrow=c(1,1))
###### AEM ######
### decide e.g. direction & build binary
plot(nbnear5, loc, col="red", pch=20, cex=2) # the connectivity we will be using
aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=0) # xy needed (ID, coordinates)
aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=45) # turn it by 45 degrees
aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=90) # turn it by 90 degrees
### build AEM from binary
aem.bin1<-aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=0)
aem1<-aem(aem.bin1)
aem1$values
barplot(aem1$values, main="Eigenvalues", cex.main=0.8)
par(mfrow=c(1,2))
s.value(loc, aem1$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem1$vectors[,2], sub="AEM 2", csub=2)
par(mfrow=c(1,1))
### build AEM with orthogonal direction (90 degree rotation)
aem.bin2<-aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=90)
aem2<-aem(aem.bin2)
aem2$values
barplot(aem2$values, main="Eigenvalues", cex.main=0.8)
par(mfrow=c(1,2))
s.value(loc, aem2$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem2$vectors[,2], sub="AEM 2", csub=2)
par(mfrow=c(1,1))
### build AEM with lower truncation
plot(nbnear1, loc, col="red", pch=20, cex=2) # our connectivity matrix
aem.bin3<-aem.build.binary(nb.object=nbnear1, xy, unit.angle="degrees", rot.angle=0)
aem3<-aem(aem.bin3)
aem3$values
barplot(aem3$values, main="Eigenvalues", cex.main=0.8)
par(mfrow=c(2,2))
s.value(loc, aem3$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem3$vectors[,2], sub="AEM 2", csub=2)
s.value(loc, aem3$vectors[,3], sub="AEM 3", csub=2)
s.value(loc, aem3$vectors[,4], sub="AEM 4", csub=2)
par(mfrow=c(1,1))
# compare to the first AEM we built
plot(nbnear5, loc, col="red", pch=20, cex=2) # connectivity matrix for aem1
par(mfrow=c(2,2))
s.value(loc, aem1$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem1$vectors[,2], sub="AEM 2", csub=2)
s.value(loc, aem1$vectors[,3], sub="AEM 3", csub=2)
s.value(loc, aem1$vectors[,4], sub="AEM 4", csub=2)
par(mfrow=c(1,1))
###### real data (mites) ######
require(vegan)
data(mite.env)
data(mite)
data(mite.xy)
mite.xy
# create nb object (spatial neighbourhoods)
nbnear.mite<-dnearneigh(as.matrix(mite.xy), 0, 1.5) # use truncation above distance of 1.5
nbnear.mite
plot(nbnear.mite, mite.xy, col="red", pch=20, cex=2)
swm.mite<-nb2listw(nbnear.mite) # transform to spatial weighting matrix
mem.mite<-mem(swm.mite) # generate MEMs
barplot(attr(mem.mite, "values"), main="Eigenvalues", cex.main=0.8)
par(mfrow=c(2,2))
s.value(mite.xy, mem.mite$MEM1, sub="MEM 1", csub=2)
s.value(mite.xy, mem.mite$MEM2, sub="MEM 2", csub=2)
s.value(mite.xy, mem.mite$MEM3, sub="MEM 3", csub=2)
s.value(mite.xy, mem.mite$MEM4, sub="MEM 4", csub=2)
par(mfrow=c(1,1))
# select for significant MEMs
rda_0<-rda(mite>0 ~ 1, mem.mite)  # Model with intercept only
rda_1<-rda(mite>0 ~ ., mem.mite)  # Model with all explanatory variables
ordistep(rda_0, scope=formula(rda_1), perm.max=200, direction="forward") # forward selection of sign. MEMs
sign.MEM<-mem.mite[, c(1:6,29,31,62,64,68)]
# select environmental predictors
mite.env
env12<-decostand(mite.env[,1:2], method="standardize")
d.Substrate<-model.matrix(~factor(mite.env$Substrate)) # create dummies for one of the fact. var.
d.Substrate
env<-cbind(env12, d.Substrate[,-1]) # bind continous + dummy variables
# partition community variation
vp1<-varpart(mite>0, env, sign.MEM)
plot(vp1)
)
tidy_source(
require(adespatial) # for most of the functions
require(ade4) # for s.value plots...
require(spdep) # for MEM, cell2nb...
###### Create fictitious geographical coordinates ######
xy<-cbind(1:15, expand.grid(1:3, 1:5)) # 15 locations in a 3x5 grid
plot(Var2~Var1, data=xy, pch=20, cex=2)
loc<-as.matrix(xy[,2:3]) # these will be our coordinates
ID<-xy[,1] # ID of the sites
###### construction of object of class nb (spdep) with a regular connectivity pattern ######
nb<-cell2nb(3, 5, "rook") # or "queen" for additional diagonal connections
nb #check nr of links
plot(nb, xy[,2:3], col="red", pch=20, cex=2)
###### how to set the length and thus the number of connections ######
nbnear1<-dnearneigh(loc, 0, 1, row.names=ID) # 0 is the lower, 1 is the upper threshold = truncation distance
nbnear1 # same, 44 links
plot(nbnear1, loc, col="red", pch=20, cex=2)
nbnear2<-dnearneigh(loc, 0, 2, row.names=ID)
nbnear2 # nr of links increased
plot(nbnear2, loc, col="red", pch=20, cex=2) # extra links: diagonal + overlapping
nbnear5<-dnearneigh(loc, 0, 5, row.names=ID) # connects them all (>4.472136)
nbnear5
plot(nbnear5, loc, col="red", pch=20, cex=2)
###### construct MEMs ######
###### 1st step: construct spatial weighting matrices (listw) from spatial neighborhood objects (nb) ######
### function for this: nb2listw()
swm1<-nb2listw(nbnear5) # works with simple row-standardization, gives uniform weights to links
swm1
str(swm1)
swm1$weights # weights are the same
### weights can also be applied based on distance between neighbours
### here weights are defined as a function of distance e.g. 1-dij/max(dij)
dist1<-nbdists(nbnear5, loc) # obtain pairwise distances
str(dist1)
w.dist<-lapply(dist1, function(x) 1-x/max(dist(loc))) # you can define any weight here, this is the most used function
swm2<-nb2listw(nbnear5, glist=w.dist)
swm2
str(swm2)
swm2$weights
swm2$weights[[1]] # easiest to check e.g. weights connecting site 1 to all the others
# note the zero: this is the longest distance in the matrix, should be zero due to the function we gave
print(listw2mat(swm2),digits=3) # check the full matrix with all weights
createlistw() # interface that helps you to find the right weight + graph type;
# useful R coding help on the right
###### 2nd step: construct MEMs from spatial weighting matrices (listw) ######
### function for this: mem()
plot(nbnear1, loc, col="red", pch=20, cex=2) # use this simple case first
swm1<-nb2listw(nbnear1)
mem1<-mem(swm1)
mem1
str(mem1)
attr(mem1, "values") # eigenvalues
barplot(attr(mem1, "values"), main="Eigenvalues", cex.main=0.8)
# positive eigenvalue: MEM has positive autocorrelation
plot(mem1) # not too informative (but good for transects)
plot(mem1, SpORcoords=loc, nb=nbnear1) # without nb, connections are not plotted
plot(mem1$MEM1~loc[,2], pch=20, cex=2)
plot(mem1$MEM2~loc[,1], pch=20, cex=2)
mem2<-mem(swm2) # with longer possible connections
barplot(attr(mem2, "values"), main="Eigenvalues", cex.main=0.8)
plot(mem2, SpORcoords=loc, nb=nbnear2) # still very similar MEMs
# compare 1st MEM from both models
par(mfrow=c(1,2))
s.value(loc, mem1$MEM1, sub="MEM 1", csub=2)
s.value(loc, mem2$MEM1, sub="MEM 1", csub=2)
par(mfrow=c(1,1))
###### AEM ######
### decide e.g. direction & build binary
plot(nbnear5, loc, col="red", pch=20, cex=2) # the connectivity we will be using
aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=0) # xy needed (ID, coordinates)
aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=45) # turn it by 45 degrees
aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=90) # turn it by 90 degrees
### build AEM from binary
aem.bin1<-aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=0)
aem1<-aem(aem.bin1)
aem1$values
barplot(aem1$values, main="Eigenvalues", cex.main=0.8)
par(mfrow=c(1,2))
s.value(loc, aem1$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem1$vectors[,2], sub="AEM 2", csub=2)
par(mfrow=c(1,1))
### build AEM with orthogonal direction (90 degree rotation)
aem.bin2<-aem.build.binary(nb.object=nbnear5, xy, unit.angle="degrees", rot.angle=90)
aem2<-aem(aem.bin2)
aem2$values
barplot(aem2$values, main="Eigenvalues", cex.main=0.8)
par(mfrow=c(1,2))
s.value(loc, aem2$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem2$vectors[,2], sub="AEM 2", csub=2)
par(mfrow=c(1,1))
### build AEM with lower truncation
plot(nbnear1, loc, col="red", pch=20, cex=2) # our connectivity matrix
aem.bin3<-aem.build.binary(nb.object=nbnear1, xy, unit.angle="degrees", rot.angle=0)
aem3<-aem(aem.bin3)
aem3$values
barplot(aem3$values, main="Eigenvalues", cex.main=0.8)
par(mfrow=c(2,2))
s.value(loc, aem3$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem3$vectors[,2], sub="AEM 2", csub=2)
s.value(loc, aem3$vectors[,3], sub="AEM 3", csub=2)
s.value(loc, aem3$vectors[,4], sub="AEM 4", csub=2)
par(mfrow=c(1,1))
# compare to the first AEM we built
plot(nbnear5, loc, col="red", pch=20, cex=2) # connectivity matrix for aem1
par(mfrow=c(2,2))
s.value(loc, aem1$vectors[,1], sub="AEM 1", csub=2)
s.value(loc, aem1$vectors[,2], sub="AEM 2", csub=2)
s.value(loc, aem1$vectors[,3], sub="AEM 3", csub=2)
s.value(loc, aem1$vectors[,4], sub="AEM 4", csub=2)
par(mfrow=c(1,1))
###### real data (mites) ######
require(vegan)
data(mite.env)
data(mite)
data(mite.xy)
mite.xy
# create nb object (spatial neighbourhoods)
nbnear.mite<-dnearneigh(as.matrix(mite.xy), 0, 1.5) # use truncation above distance of 1.5
nbnear.mite
plot(nbnear.mite, mite.xy, col="red", pch=20, cex=2)
swm.mite<-nb2listw(nbnear.mite) # transform to spatial weighting matrix
mem.mite<-mem(swm.mite) # generate MEMs
barplot(attr(mem.mite, "values"), main="Eigenvalues", cex.main=0.8)
par(mfrow=c(2,2))
s.value(mite.xy, mem.mite$MEM1, sub="MEM 1", csub=2)
s.value(mite.xy, mem.mite$MEM2, sub="MEM 2", csub=2)
s.value(mite.xy, mem.mite$MEM3, sub="MEM 3", csub=2)
s.value(mite.xy, mem.mite$MEM4, sub="MEM 4", csub=2)
par(mfrow=c(1,1))
# select for significant MEMs
rda_0<-rda(mite>0 ~ 1, mem.mite)  # Model with intercept only
rda_1<-rda(mite>0 ~ ., mem.mite)  # Model with all explanatory variables
ordistep(rda_0, scope=formula(rda_1), perm.max=200, direction="forward") # forward selection of sign. MEMs
sign.MEM<-mem.mite[, c(1:6,29,31,62,64,68)]
# select environmental predictors
mite.env
env12<-decostand(mite.env[,1:2], method="standardize")
d.Substrate<-model.matrix(~factor(mite.env$Substrate)) # create dummies for one of the fact. var.
d.Substrate
env<-cbind(env12, d.Substrate[,-1]) # bind continous + dummy variables
# partition community variation
vp1<-varpart(mite>0, env, sign.MEM)
plot(vp1))
tidy_source(nbnear1<-dnearneigh(loc, 0, 1, row.names=ID) # 0 is the lower, 1 is the upper threshold = truncation distance
nbnear1 # same, 44 links
)
tidy_source()
library(adespatial)  # for most of the functions
library(ade4)  # for s.value plots...
library(spdep)  # for MEM, cell2nb...
###### Create fictitious geographical coordinates ######
xy <- cbind(1:15, expand.grid(1:3, 1:5))  # 15 locations in a 3x5 grid
plot(Var2 ~ Var1, data = xy, pch = 20, cex = 2)
loc <- as.matrix(xy[, 2:3])  # these will be our coordinates
ID <- xy[, 1]  # ID of the sites
###### construction of object of class nb (spdep) with a regular
###### connectivity pattern ######
nb <- cell2nb(3, 5, "rook")  # or 'queen' for additional diagonal connections
nb  #check nr of links
plot(nb, xy[, 2:3], col = "red", pch = 20, cex = 2)
###### how to set the length and thus the number of connections ######
nbnear1 <- dnearneigh(loc, 0, 1, row.names = ID)  # 0 is the lower, 1 is the upper threshold = truncation distance
nbnear1  # same, 44 links
###### construction of object of class nb (spdep) with a regular
###### connectivity pattern ######
nb <- cell2nb(3, 5, "rook")  # or 'queen' for additional diagonal connections
nb  #check nr of links
plot(nb, xy[, 2:3], col = "red", pch = 20, cex = 2)
###### how to set the length and thus the number of connections ######
nbnear1 <- dnearneigh(loc, 0, 1, row.names = ID)  # 0 is the lower, 1 is the upper threshold = truncation distance
nbnear1  # same, 44 links
plot(nbnear1, loc, col = "red", pch = 20, cex = 2)
nbnear2 <- dnearneigh(loc, 0, 2, row.names = ID)
nbnear2  # nr of links increased
plot(nbnear2, loc, col = "red", pch = 20, cex = 2)  # extra links: diagonal + overlapping
nbnear5 <- dnearneigh(loc, 0, 5, row.names = ID)  # connects them all (>4.472136)
nbnear5
plot(nbnear5, loc, col = "red", pch = 20, cex = 2)
###### construct MEMs ###### 1st step: construct spatial weighting
###### matrices (listw) from spatial neighborhood objects (nb) ######
###### function for this: nb2listw()
swm1 <- nb2listw(nbnear5)  # works with simple row-standardization, gives uniform weights to links
swm1
str(swm1)
swm1$weights  # weights are the same
### weights can also be applied based on distance between neighbours
### here weights are defined as a function of distance e.g.
### 1-dij/max(dij)
dist1 <- nbdists(nbnear5, loc)  # obtain pairwise distances
str(dist1)
w.dist <- lapply(dist1, function(x) 1 - x/max(dist(loc)))  # you can define any weight here, this is the most used function
?nb2listw
dist1 <- nbdists(nbnear5, loc)  # obtain pairwise distances
str(dist1)
w.dist <- lapply(dist1, function(x) 1 - x/max(dist(loc)))  # you can define any weight here, this is the most used function
swm2 <- nb2listw(nbnear5, glist = w.dist)
swm2
str(swm2)
swm2$weights
swm2$weights[[1]]  # easiest to check e.g. weights connecting site 1 to all the others
# note the zero: this is the longest distance in the matrix, should
# be zero due to the function we gave
print(listw2mat(swm2), digits = 3)  # check the full matrix with all weights
createlistw()  # interface that helps you to find the right weight + graph type;
###### 2nd step: construct MEMs from spatial weighting matrices (listw)
###### ###### function for this: mem()
plot(nbnear1, loc, col = "red", pch = 20, cex = 2)  # use this simple case first
swm1 <- nb2listw(nbnear1)
mem1 <- mem(swm1)
mem1
str(mem1)
attr(mem1, "values")  # eigenvalues
barplot(attr(mem1, "values"), main = "Eigenvalues", cex.main = 0.8)
# positive eigenvalue: MEM has positive autocorrelation
plot(mem1)  # not too informative (but good for transects)
plot(mem1, SpORcoords = loc, nb = nbnear1)  # without nb, connections are not plotted
plot(mem1$MEM1 ~ loc[, 2], pch = 20, cex = 2)
plot(mem1$MEM2 ~ loc[, 1], pch = 20, cex = 2)
mem2 <- mem(swm2)  # with longer possible connections
barplot(attr(mem2, "values"), main = "Eigenvalues", cex.main = 0.8)
plot(mem2, SpORcoords = loc, nb = nbnear2)  # still very similar MEMs
# compare 1st MEM from both models
par(mfrow = c(1, 2))
s.value(loc, mem1$MEM1, sub = "MEM 1", csub = 2)
s.value(loc, mem2$MEM1, sub = "MEM 1", csub = 2)
par(mfrow = c(1, 1))
###### AEM ###### decide e.g. direction & build binary
plot(nbnear5, loc, col = "red", pch = 20, cex = 2)  # the connectivity we will be using
aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees", rot.angle = 0)  # xy needed (ID, coordinates)
aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees", rot.angle = 45)  # turn it by 45 degrees
aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees", rot.angle = 90)  # turn it by 90 degrees
### build AEM from binary
aem.bin1 <- aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees",
rot.angle = 0)
aem1 <- aem(aem.bin1)
aem1$values
barplot(aem1$values, main = "Eigenvalues", cex.main = 0.8)
par(mfrow = c(1, 2))
s.value(loc, aem1$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem1$vectors[, 2], sub = "AEM 2", csub = 2)
par(mfrow = c(1, 1))
### build AEM with orthogonal direction (90 degree rotation)
aem.bin2 <- aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees",
rot.angle = 90)
aem2 <- aem(aem.bin2)
aem2$values
barplot(aem2$values, main = "Eigenvalues", cex.main = 0.8)
par(mfrow = c(1, 2))
s.value(loc, aem2$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem2$vectors[, 2], sub = "AEM 2", csub = 2)
par(mfrow = c(1, 1))
### build AEM with lower truncation
plot(nbnear1, loc, col = "red", pch = 20, cex = 2)  # our connectivity matrix
aem.bin3 <- aem.build.binary(nb.object = nbnear1, xy, unit.angle = "degrees",
rot.angle = 0)
aem3 <- aem(aem.bin3)
aem3$values
barplot(aem3$values, main = "Eigenvalues", cex.main = 0.8)
par(mfrow = c(2, 2))
s.value(loc, aem3$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem3$vectors[, 2], sub = "AEM 2", csub = 2)
s.value(loc, aem3$vectors[, 3], sub = "AEM 3", csub = 2)
s.value(loc, aem3$vectors[, 4], sub = "AEM 4", csub = 2)
par(mfrow = c(1, 1))
# compare to the first AEM we built
plot(nbnear5, loc, col = "red", pch = 20, cex = 2)  # connectivity matrix for aem1
aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees", rot.angle = 0)  # xy needed (ID, coordinates)
### build AEM from binary
aem.bin1 <- aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees",
rot.angle = 0)
aem1 <- aem(aem.bin1)
aem1$values
barplot(aem1$values, main = "Eigenvalues", cex.main = 0.8)
par(mfrow = c(1, 2))
s.value(loc, aem1$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem1$vectors[, 2], sub = "AEM 2", csub = 2)
par(mfrow = c(1, 1))
### build AEM with orthogonal direction (90 degree rotation)
aem.bin2 <- aem.build.binary(nb.object = nbnear5, xy, unit.angle = "degrees",
rot.angle = 90)
aem2 <- aem(aem.bin2)
aem2 <- aem(aem.bin2)
aem2$values
barplot(aem2$values, main = "Eigenvalues", cex.main = 0.8)
### compare both
s.value(loc, aem1$vectors[, 1], sub = "Model 0° AEM 1", csub = 2)
s.value(loc, aem2$vectors[, 1], sub = "Model 90° AEM 1", csub = 2)
par(mfrow = c(1, 2))
s.value(loc, aem2$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem2$vectors[, 2], sub = "AEM 2", csub = 2)
### compare both
s.value(loc, aem1$vectors[, 1], sub = "Model 0° AEM 1", csub = 2)
s.value(loc, aem2$vectors[, 1], sub = "Model 90° AEM 1", csub = 2)
### build AEM with lower truncation
plot(nbnear1, loc, col = "red", pch = 20, cex = 2)  # our connectivity matrix
aem.bin3 <- aem.build.binary(nb.object = nbnear1, xy, unit.angle = "degrees", rot.angle = 0)
par(mfrow = c(1, 1))
aem.bin3 <- aem.build.binary(nb.object = nbnear1, xy, unit.angle = "degrees", rot.angle = 0)
aem3 <- aem(aem.bin3)
aem3$values
barplot(aem3$values, main = "Eigenvalues", cex.main = 0.8)
par(mfrow = c(2, 2))
s.value(loc, aem3$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem3$vectors[, 2], sub = "AEM 2", csub = 2)
s.value(loc, aem3$vectors[, 3], sub = "AEM 3", csub = 2)
s.value(loc, aem3$vectors[, 4], sub = "AEM 4", csub = 2)
par(mfrow = c(1, 1))
# compare to the first AEM we built
plot(nbnear5, loc, col = "red", pch = 20, cex = 2)  # connectivity matrix for aem1
par(mfrow = c(2, 2))
s.value(loc, aem1$vectors[, 1], sub = "AEM 1", csub = 2)
s.value(loc, aem1$vectors[, 2], sub = "AEM 2", csub = 2)
s.value(loc, aem1$vectors[, 3], sub = "AEM 3", csub = 2)
s.value(loc, aem1$vectors[, 4], sub = "AEM 4", csub = 2)
par(mfrow = c(1, 1))
###### real data (mites) ######
library(vegan)
data(mite.env)
data(mite)
data(mite.xy)
mite.xy
# create nb object (spatial neighbourhoods)
nbnear.mite <- dnearneigh(as.matrix(mite.xy), 0, 1.5)  # use truncation above distance of 1.5
nbnear.mite
plot(nbnear.mite, mite.xy, col = "red", pch = 20, cex = 2)
swm.mite <- nb2listw(nbnear.mite)  # transform to spatial weighting matrix
mem.mite <- mem(swm.mite)  # generate MEMs
barplot(attr(mem.mite, "values"), main = "Eigenvalues", cex.main = 0.8)
par(mfrow = c(2, 2))
s.value(mite.xy, mem.mite$MEM1, sub = "MEM 1", csub = 2)
s.value(mite.xy, mem.mite$MEM2, sub = "MEM 2", csub = 2)
s.value(mite.xy, mem.mite$MEM3, sub = "MEM 3", csub = 2)
s.value(mite.xy, mem.mite$MEM4, sub = "MEM 4", csub = 2)
# select for significant MEMs
rda_0 <- rda(mite > 0 ~ 1, mem.mite)  # Model with intercept only
rda_1 <- rda(mite > 0 ~ ., mem.mite)  # Model with all explanatory variables
ordistep(rda_0, scope = formula(rda_1), perm.max = 200, direction = "forward")  # forward selection of sign. MEMs
# select for significant MEMs
rda_0 <- rda(mite > 0 ~ 1, mem.mite)  # Model with intercept only
sign.MEM <- mem.mite[, c(1:6, 29, 31, 62, 64, 68)]
# select environmental predictors
mite.env
env12 <- decostand(mite.env[, 1:2], method = "standardize")
d.Substrate <- model.matrix(~factor(mite.env$Substrate))  # create dummies for one of the fact. var.
d.Substrate
env <- cbind(env12, d.Substrate[, -1])  # bind continous + dummy variables
# partition community variation
vp1 <- varpart(mite > 0, env, sign.MEM)
plot(vp1)
par(mfrow = c(1, 1))
par(mfrow = c(2, 2))
s.value(mite.xy, mem.mite$MEM1, sub = "MEM 1", csub = 2)
s.value(mite.xy, mem.mite$MEM2, sub = "MEM 2", csub = 2)
s.value(mite.xy, mem.mite$MEM3, sub = "MEM 3", csub = 2)
s.value(mite.xy, mem.mite$MEM4, sub = "MEM 4", csub = 2)
par(mfrow = c(1, 1))
plot(vp1)
vp2 <- varpart(mite > 0, env, sign.MEM[, 1:2], sign.MEM[, 3:7])
plot(vp2)
setwd("C:/Users/Cedric/Google Drive/Bio/Projects/netlify")
getwd()
library(blogdown)
blogdown::build_site()
